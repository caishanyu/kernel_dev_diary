# platform device driver

本章介绍平台设备驱动

首先一个问题是，什么是平台设备驱动？前边已经实现的字符设备驱动，只需要调用`open()`来打开对应的设备文件，就可以通过`file_operations`文件操作接口来控制硬件

但是这种方式存在一个问题，就是设备信息和驱动代码耦合在一块了。在未来的驱动程序中，各种硬件寄存器地址随处可见，一旦硬件信息发生变化，代码就需要修改，这样是很麻烦的

为了解决这种问题，linux提出了设备驱动模型，引入总线概念来分离驱动代码和设备信息

对于I2C、SPI、USB这些常见的物理总线，内核会自动创建与之相对应的驱动总线，但还存在很多结构简单的设备，没有对应物理总线，例如rtc、led、蜂鸣器等，**为了使这些设备也能够遵循设备驱动模型，内核引入了虚拟总线——平台总线（platform bus）**

## 平台设备驱动简介

连接到平台总线上的设备，需要被**静态发现**而不是被动态探测，例如写到设备树里

**平台设备驱动程序负责在设备模型核心中实例化并注册`platform_driver`数据结构实例**，驱动提供`probe()`和`remove()`方法，用于匹配到设备、设备离开时的回调；**`probe`函数在总线驱动程序和设备匹配上时被调用**，在其中一般进行设备的初始化

平台驱动程序需要使用`platform_driver_register()`函数来将驱动程序注册到平台核心，使用`platform_driver_unregister()`函数来注销

此外可以使用`module_platform_driver()`宏，该宏会调换掉`module_init`和`module_exit`。对于不需要在init和exit中进行复杂操作的设备驱动，可以简化代码

